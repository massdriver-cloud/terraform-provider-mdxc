/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 * Original repo: https://github.com/hashicorp/terraform-provider-google
 */

package thirdparty

import (
	"encoding/json"
	"fmt"
	"reflect"
	"sort"

	"github.com/hashicorp/errwrap"
	"google.golang.org/api/cloudresourcemanager/v1"
	"google.golang.org/api/googleapi"
	"google.golang.org/api/iam/v1"
)

type conditionKey struct {
	Description string
	Expression  string
	Title       string
}

type iamBindingKey struct {
	Role      string
	Condition conditionKey
}

func (k conditionKey) Empty() bool {
	return k == conditionKey{}
}

func (k conditionKey) String() string {
	return fmt.Sprintf("%s/%s/%s", k.Title, k.Description, k.Expression)
}

func AddBinding(bindings []*cloudresourcemanager.Binding, binding *cloudresourcemanager.Binding) []*cloudresourcemanager.Binding {
	return mergeBindings(append(bindings, binding))
}

func RemoveBinding(bindings []*cloudresourcemanager.Binding, binding *cloudresourcemanager.Binding) []*cloudresourcemanager.Binding {
	return subtractFromBindings(bindings, binding)
}

func Convert(item, out interface{}) error {
	bytes, err := json.Marshal(item)
	if err != nil {
		return err
	}

	err = json.Unmarshal(bytes, out)
	if err != nil {
		return err
	}

	// Converting between maps and structs only occurs when autogenerated resources convert the result
	// of an HTTP request. Those results do not contain omitted fields, so no need to set them.
	if _, ok := item.(map[string]interface{}); !ok {
		setOmittedFields(item, out)
	}

	return nil
}

// Removes given role+condition/bound-member pairs from the given Bindings (i.e subtraction).
func subtractFromBindings(bindings []*cloudresourcemanager.Binding, toRemove ...*cloudresourcemanager.Binding) []*cloudresourcemanager.Binding {
	currMap := createIamBindingsMap(bindings)
	toRemoveMap := createIamBindingsMap(toRemove)

	for key, removeSet := range toRemoveMap {
		members, ok := currMap[key]
		if !ok {
			continue
		}
		// Remove all removed members
		for m := range removeSet {
			delete(members, m)
		}
		// Remove role+condition from bindings
		if len(members) == 0 {
			delete(currMap, key)
		}
	}

	return listFromIamBindingMap(currMap)
}

func setOmittedFields(item, out interface{}) {
	// Both inputs must be pointers, see https://blog.golang.org/laws-of-reflection:
	// "To modify a reflection object, the value must be settable."
	iVal := reflect.ValueOf(item).Elem()
	oVal := reflect.ValueOf(out).Elem()

	// Loop through all the fields of the struct to look for omitted fields and nested fields
	for i := 0; i < iVal.NumField(); i++ {
		iField := iVal.Field(i)
		if isEmptyValue(iField) {
			continue
		}

		fieldInfo := iVal.Type().Field(i)
		oField := oVal.FieldByName(fieldInfo.Name)

		// Only look at fields that exist in the output struct
		if !oField.IsValid() {
			continue
		}

		// If the field contains a 'json:"="' tag, then it was omitted from the Marshal/Unmarshal
		// call and needs to be added back in.
		if fieldInfo.Tag.Get("json") == "-" {
			oField.Set(iField)
		}

		// If this field is a struct, *struct, []struct, or []*struct, recurse.
		if iField.Kind() == reflect.Struct {
			setOmittedFields(iField.Addr().Interface(), oField.Addr().Interface())
		}
		if iField.Kind() == reflect.Ptr && iField.Type().Elem().Kind() == reflect.Struct {
			setOmittedFields(iField.Interface(), oField.Interface())
		}
		if iField.Kind() == reflect.Slice && iField.Type().Elem().Kind() == reflect.Struct {
			for j := 0; j < iField.Len(); j++ {
				setOmittedFields(iField.Index(j).Addr().Interface(), oField.Index(j).Addr().Interface())
			}
		}
		if iField.Kind() == reflect.Slice && iField.Type().Elem().Kind() == reflect.Ptr &&
			iField.Type().Elem().Elem().Kind() == reflect.Struct {
			for j := 0; j < iField.Len(); j++ {
				setOmittedFields(iField.Index(j).Interface(), oField.Index(j).Interface())
			}
		}
	}
}

func isEmptyValue(v reflect.Value) bool {
	if !v.IsValid() {
		return true
	}

	switch v.Kind() {
	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
		return v.Len() == 0
	case reflect.Bool:
		return !v.Bool()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0
	case reflect.Interface, reflect.Ptr:
		return v.IsNil()
	}
	return false
}

// Flattens a list of Bindings so each role+condition has a single Binding with combined members
func mergeBindings(bindings []*cloudresourcemanager.Binding) []*cloudresourcemanager.Binding {
	bm := createIamBindingsMap(bindings)
	return listFromIamBindingMap(bm)
}

func createIamBindingsMap(bindings []*cloudresourcemanager.Binding) map[iamBindingKey]map[string]struct{} {
	bm := make(map[iamBindingKey]map[string]struct{})
	// Get each binding
	for _, b := range bindings {
		members := make(map[string]struct{})
		key := iamBindingKey{b.Role, conditionKeyFromCondition(b.Condition)}
		// Initialize members map
		if _, ok := bm[key]; ok {
			members = bm[key]
		}
		// Get each member (user/principal) for the binding
		for _, m := range b.Members {
			members[m] = struct{}{}
		}
		if len(members) > 0 {
			bm[key] = members
		} else {
			delete(bm, key)
		}
	}
	return bm
}

// Return list of Bindings for a map of role to member sets
func listFromIamBindingMap(bm map[iamBindingKey]map[string]struct{}) []*cloudresourcemanager.Binding {
	rb := make([]*cloudresourcemanager.Binding, 0, len(bm))
	var keys []iamBindingKey
	for k := range bm {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		keyI := keys[i]
		keyJ := keys[j]
		return fmt.Sprintf("%s%s", keyI.Role, keyI.Condition.String()) < fmt.Sprintf("%s%s", keyJ.Role, keyJ.Condition.String())
	})
	for _, key := range keys {
		members := bm[key]
		if len(members) == 0 {
			continue
		}
		b := &cloudresourcemanager.Binding{
			Role:    key.Role,
			Members: stringSliceFromGolangSet(members),
		}
		if !key.Condition.Empty() {
			b.Condition = &cloudresourcemanager.Expr{
				Description: key.Condition.Description,
				Expression:  key.Condition.Expression,
				Title:       key.Condition.Title,
			}
		}
		rb = append(rb, b)
	}
	return rb
}

func conditionKeyFromCondition(condition *cloudresourcemanager.Expr) conditionKey {
	if condition == nil {
		return conditionKey{}
	}
	return conditionKey{condition.Description, condition.Expression, condition.Title}
}

func resourceManagerToIamPolicy(p *cloudresourcemanager.Policy) (*iam.Policy, error) {
	out := &iam.Policy{}
	err := Convert(p, out)
	if err != nil {
		return nil, fmt.Errorf("Cannot convert a v1 policy to a iam policy: %v", err)
	}
	return out, nil
}

func iamToResourceManagerPolicy(p *iam.Policy) (*cloudresourcemanager.Policy, error) {
	out := &cloudresourcemanager.Policy{}
	err := Convert(p, out)
	if err != nil {
		return nil, errwrap.Wrapf("Cannot convert a iam policy to a v1 policy: {{err}}", err)
	}
	return out, nil
}

func stringSliceFromGolangSet(sset map[string]struct{}) []string {
	ls := make([]string, 0, len(sset))
	for s := range sset {
		ls = append(ls, s)
	}
	sort.Strings(ls)

	return ls
}

func IsConflictError(err error) bool {
	if e, ok := err.(*googleapi.Error); ok && (e.Code == 409 || e.Code == 412) {
		return true
	} else if !ok && errwrap.ContainsType(err, &googleapi.Error{}) {
		e := errwrap.GetType(err, &googleapi.Error{}).(*googleapi.Error)
		if e.Code == 409 || e.Code == 412 {
			return true
		}
	}
	return false
}
